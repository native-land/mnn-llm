✦ 分词器业务流程整理如下：

1. 整体流程
   分词器的主要职责是将自然语言文本转换为模型可以处理的整数令牌（token）序列，并支持反向操作，即将令牌序
   列还原为文本。流程从tokenizer_demo.cpp中的main函数开始，通过调用Tokenizer类的接口完成。

2. 初始化阶段
1. 创建分词器实例：
    - main函数接收两个参数：分词器模型文件路径 (tokenizer.txt) 和提示文本文件路径 (prompt.txt)。
    - 调用Tokenizer::createTokenizer(tokenizer_path)工厂方法，根据模型文件中的类型标识创建对应类型的分
      词器对象（如Sentencepiece, Tiktoken, BertTokenizer, HuggingfaceTokenizer）。
    - createTokenizer内部会读取模型文件，加载特殊令牌（如BOS、EOS等）和词汇表数据。

2. 加载特殊令牌：
    - 调用load_special方法，从文件中读取特殊令牌、停止令牌和前缀令牌的ID列表并保存。

3. 加载词汇表：
    - 调用各子类实现的load_vocab方法，加载具体分词算法所需的词汇表数据（如token到ID的映射、片段信息、
      合并规则等）。

3. 编码（文本 -> token ID）流程
1. 读取并处理提示文本：
    - main函数从prompt.txt逐行读取文本。
    - 忽略以#开头的注释行。
    - 将文本中的\\n替换为换行符\n。
    - 为每行文本添加前缀\n### Human: 和后缀\n### Assistant: ，构造最终的查询字符串。

2. 调用编码接口：
    - main函数调用tokenizer->encode(query)对构造好的查询字符串进行编码。

3. 基础编码处理：
    - Tokenizer::encode方法首先将prefix_tokens_（如BOS令牌）加入结果列表。
    - 遍历输入文本，检查是否存在特殊令牌。如果存在，则在特殊令牌处切分文本，对普通文本部分调用具体分词
      器的encode方法，将特殊令牌ID直接加入结果列表。
    - 如果不存在特殊令牌，则直接对整个输入字符串调用具体分词器的encode方法。

4. 具体分词器实现：
    - Sentencepiece：
        - 调用bpe_encode使用BPE算法将文本分词为片段。
        - 遍历片段，通过piece_to_id查找ID。对于未知片段，如果启用了字节回退
          (byte_fall_back_)，则将其分解为UTF-8字节，再将每个字节转换为特殊片段（如<0x41>）并查找ID。
    - Tiktoken：
        - 使用贪心最长匹配算法。从文本开头开始，查找最长的已知token，将其ID加入结果，然后移动到下一个未
          匹配位置，重复此过程。
    - BertTokenizer：
        - 首先将文本预分词为基本单元（字母数字序列、标点符号等）。
        - 对每个基本单元调用word_piece方法：尝试匹配整个单元，若失败则分解为以##为前缀的子词片段，直到无
          法匹配则使用[UNK]。
    - HuggingfaceTokenizer：
        - 使用正则表达式将文本分割为粗粒度token。
        - 对每个token进行字节级预处理：将每个字节映射为预定义的unicode字符。
        - 对预处理后的unicode token调用bpe方法进行BPE分词。
        - 将BPE分词结果转换回UTF-8字符串token。
        - 通过encoder_映射将最终的字符串token转换为ID。

4. 解码（token ID -> 文本）流程
1. 调用解码接口：
    - main函数在编码后，遍历得到的token ID序列，对每个ID调用tokenizer->decode(id)进行解码。

2. 具体分词器实现：
    - Sentencepiece：
        - 通过ID在sentence_pieces_中查找对应的片段字符串。将片段中的特殊下划线字符▁替换为空格。
    - Tiktoken & BertTokenizer & HuggingfaceTokenizer：
        - 通过ID在decoder_向量中查找对应的字符串token。
        - HuggingfaceTokenizer的解码还会进行反向字节级处理：将token字符串转换为宽字符串，再将宽字符通过u
          2b_映射回原始字节，最后将字节序列转换为字符串。

5. 输出与验证
- main函数打印编码得到的token ID序列和解码得到的字符串，用于验证分词器的正确性。